
### Revolutionising Business Processes: Integrating Slack with AWS Using Serverless Architectures

### **Introduction**

Smart automation is a pivotal component in the dynamic arena of business operations, greatly augmenting efficiency. Slack, with its widespread use and extensive integrations, is one of the platforms driving this automation. Today’s companies are burdened with essential yet time-consuming tasks, from the detailed process of onboarding new team members to the careful coordination of peer reviews and project workflows. This is where automation comes in, transforming these labor-intensive activities into streamlined processes. This integration revolutionizes not just everyday tasks but also sparks innovation by, for example, sending direct message alerts for cloud resource overspending — a significant advantage, especially when integrated with external resources.

The traditional go-to solution, autogenerated emails, while useful, often miss the mark in engagement and seamlessness. Contrast that with the dynamic alert features on homepages, which cut through the noise, delivering crucial updates right when users need them.

We can enhance these capabilities with custom serverless Slack bots. While standard Slack apps offer basic functionality like tracking sick days or device security alerts, they might only partially cater to unique organizational needs. Custom bots are where you get to play. At my own company, for example, we’ve leveraged these bots for everything from social pairings using optimisation algorithms to more complex integrations, all seamlessly melding with our existing processes.

Serverless computing stands as the cornerstone of our technological metamorphosis. It champions a scale-to-zero model, dynamically tailoring itself to your traffic requirements, thereby driving efficiency as you only pay for the resources utilised. Lambda functions, woven into the fabric of Slack apps, respond to each user interaction, igniting a cascade of tailored actions. This is efficiency and responsiveness redefined.

The AWS Cloud Development Kit (CDK), a significant driving force in this transformation, isn't just a tool. It significantly simplifies the creation of custom Slack integrations by automating the deployment and management of cloud resources. Embodying the essence of Infrastructure as Code, CDK is a developer’s dream, simplifying the deployment and management of cloud resources. With the CDK in our arsenal, let’s embark on a journey to transform how businesses operate, blending efficiency with innovation in ways we’ve only just begun to explore.

### **Example Application**

In this walkthrough, I’ll guide you through the process of creating a Slack app in the console and establishing an event bus — a central nervous system for distributing commands from Slack to individual lambdas responsible for performing tasks. While setting up two example events as a starting point, we’ll lay the groundwork for expanding to numerous other operations. We will render a simple homepage and respond to a button click, all orchestrated within the handler of a Lambda. Our focus will also extend to creating an efficient routing system, channelling requests from Slack through the event bus to our lambdas, and ensuring a robust and responsive solution.

### **Create a New Slack App**

Start by following the [Slack API Hello World tutorial](https://api.slack.com/tutorials/hello-world-bolt) steps. This guide assists in creating a basic Slack app. During this process, note the ‘SLACK_SIGNING_SECRET’ and ‘SLACK_BOT_TOKEN’, which are critical for your app’s functionality and security. These values are found in the Basic Information and OAuth & Permissions pages, respectively. Configuring the app is an iterative process, you won’t be able to

---

### **Create a Backend Serverless Stack**

CDK is an influential toolkit used to create Infrastructure as Code (IaC). Utilizing the full capabilities of modern programming languages, CDK promotes scalability, repeatability, and efficient resource management, enabling developers to model and provision their cloud resources in their language of choice. To automate business processes, construct the serverless stack from the ground up, starting with individual resources like lambdas and an event bus. As you progress, you’ll interconnect these components to form a complete stack. The architectural diagram below previews the upcoming schematic.

!https://cdn-images-1.medium.com/max/1600/1*pVXjtFAegvDJe3T7AVXdxQ.png

This visual guide illuminates the flow and dependencies between the various components. As we delve into the specifics of each resource creation, keep this roadmap in mind.

### **Set Up an EventBridge Event Bus**

At the core of the interaction between your Slack application and AWS backend is the ‘/slack/events’ API endpoint. This vital endpoint acts as the primary conduit for all incoming and outgoing interactions between Slack and AWS. To efficiently parse and route various events and actions within your system, implementing an EventBus is crucial. It applies rules to incoming events to determine the appropriate resource for forwarding the action.

The key component is the **`putEvent`** function, which utilises the EventBridge client to manage event distribution. Each event, identified by its unique action, is routed to a specific Lambda function for processing the corresponding response. Below is the code for the EventBridge Adapter and the **`putEvent`** function.

```
export class EventBridgeAdapter {
  eventBus: string;

  constructor(eventBus: string) {
    this.eventBus = eventBus;
  }

  putEvent(
    action: string,
    payload: Record<string, unknown>,
    detailType: string,
  ): Promise<PutEventsCommandOutput> {

    const event: PutEventsRequestEntry = {
      Source: action,
      Detail: JSON.stringify({ ...payload }),
      DetailType: detailType,
      EventBusName: this.eventBus,
    };

    client = new EventBridgeClient();

    const command = new PutEventsCommand({
      Entries: [event],
    });

    return client.send(command);
  }
}
```

**Crafting Lambda Functions: The Driving Forces Behind Slack Events**

We now delve into creating Lambda functions, each specifically designed to handle different Slack events. In this example, we’ll focus on two actions, demonstrating how the lambda structure can be adapted for various purposes.

A crucial step in this process is the instantiation of a new Bolt App and AWSLambdaReceiver within each lambda handler. This step is vital to avoid potential issues such as unintended actions or delayed responses, which can occur if these instances persist outside the handler.

The first action we’ll explore is the **`app_home_opened`** event, which is triggered when a user accesses the home tab of the app. This lambda function aims to render a user-specific page, which could include personalised content like targets, countdowns, or data from external services like DynamoDB.

```
export const handler = async event => {
  const { token, user } = event.detail;

  const awsLambdaReceiver = new AwsLambdaReceiver({
    signingSecret: <SLACK_SIGNING_SECRET>,
  });

  // Instantiate app
  const app = new App({
    token: <SLACK_BOT_TOKEN>,
    receiver: awsLambdaReceiver,
  });

  // Display App Home
  const homeView: HomeView = {
    type: "home",
    callback_id: "home_view",
    blocks: createBlocksView(user)
  };

  await app.client.views.publish({
    token, user, view: homeView,
  });

 await awsLambdaReceiver.start()
};
```

The second function showcases the dynamic capabilities of Slack integration, demonstrating how to send reminder messages and initiate direct messages. These messages can be sent either to a general channel or as a direct message to a specific user.

```
// Post message into a channel
await app.client.chat.postMessage({
  channel: <SLACK_CHANNEL_ID>,
  message: createMessage()
});

// Or send the message as direct message to a user
const result = await app.client.conversations.open({
  token: <SLACK_BOT_TOKEN>
  users: <SLACK_USER_ID>,
});

await app.client.chat.postMessage({
  channel: result.channel?.id,
  message: createMessage()
});
```

Finally, to connect the event bridge with the lambda function, we create a rule. This rule specifies the event pattern and targets the lambda function, ensuring that the right actions are triggered by specific events.

```
new Rule(homeViewLambda, "on-home-view-opened", {
  eventBus,
  eventPattern: {
    source: ["application.slackIntegration"],
    detailType: ["app_home_opened"],
  },
  targets: [new LambdaFunction(homeViewLambda.homeViewFunction)],
});
```

---

**Create Landing Lambda API**

Having established our event bus and set up functions to forward events, it’s time to implement the initial landing Lambda function. This function acts as the primary receiver for all incoming, unfiltered requests from the Slack application.

The landing Lambda API filters actions based on their action IDs. This filtering is essential for routing requests accurately. We specify a source, in this case, **`application.slackIntegration`**, to align with our predefined event rules. While we have the flexibility to define source and destination values, it’s crucial to match them with the event rules established earlier for consistent event handling.

The following code demonstrates the setup of the landing Lambda API:

```
const eventBridge = new EventBridgeAdapter();

// Handle 'app_home_opened' event
app.event('app_home_opened', async ({ event: home_event, context: home_context }) => {
  const token = home_context.botToken;
  const user = home_event.user;

  await eventBridge.putEvent(
    'application.slackIntegration', // SOURCE
    { token, user },                // Variables to forward
    'app_home_opened',              // DESTINATION
  );
});

// Handle 'home_button_click' action
app.action('home_button_click', async ({ ack, action }) => {
  await ack();
  await eventBridge.putEvent(
    'application.slackIntegration',
    { ...action },
    'reminder.clicked',
  );
});

// ... Continue with possible actions

const response = await awsLambdaReceiver.start();
return response(event, context, callback);
```

**Create Stack to Link Services**

In the final step, we establish an API Gateway. This serves as a crucial bridge between our internal AWS resources and the external Slack application, facilitating seamless communication. Utilizing CloudFormation and the CDK for stack creation offers effortless management of resources. This approach allows for easy construction and deconstruction of services as needed, providing flexibility and control over our cloud infrastructure.

The following code snippet illustrates how to configure the API Gateway and link it with Lambda functions designed for handling specific Slack events:

```
// Initialize the Slack Integration Lambda function
const slackIntegrationFn = new SlackIntegration(this, 'slackIntegrationFn', {
  eventBus: eventBridge.bus
});

// Configuring the Slack API in API Gateway
const slack = api.root.addResource('slack');
const events = slack.addResource('events');
const slackIntegrationFnIntegration = new LambdaIntegration(
  slackIntegrationFn.slackIntegrationFunction,
);
events.addMethod('POST', slackIntegrationFnIntegration);

// Setting up individual Lambda functions for each Slack event
new homeViewLambda(this, "homeViewFn", {
  eventBus: eventBridge.bus,
});ty
```

### **Conclusion**

In summary, this guide has walked you through a detailed step-by-step process of integrating Slack with AWS. We achieved this by leveraging serverless solutions and the AWS CDK, tools that are becoming increasingly prevalent in the industry. This integration empowers businesses with custom Slack bots that automate and streamline processes, significantly enhancing efficiency and user interaction.

By detailing the creation of a Slack app, establishing a serverless backend, and linking these via an API Gateway, we’ve demonstrated how to build a responsive, scalable system for handling Slack events. This setup offers great potential for customisation, meeting diverse organisational needs.

This integration strategy stands as a testament to the power of combining Slack’s collaborative capabilities with AWS’s robust backend processing, paving the way for businesses to innovate and thrive in a digital-first environment.